<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>whowin - 发表我个人原创作品的技术博客</title>
    <link>https://whowin.gitee.io/</link>
    <description>Recent content on whowin - 发表我个人原创作品的技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 11 Jan 2024 16:43:29 +0800</lastBuildDate><atom:link href="https://whowin.gitee.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在ubuntu上的18个非常实用的命令行工具软件</title>
      <link>https://whowin.gitee.io/post/blog/linux/0010-19-useful-tools-in-ubuntu/</link>
      <pubDate>Thu, 11 Jan 2024 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0010-19-useful-tools-in-ubuntu/</guid>
      <description>&lt;p&gt;使用Ubuntu的过程中，在终端上使用命令行工具是非常常见的事情，熟练地掌握命令行工具是使用ubuntu必不可少的技能，即便是Ubuntu的初学者，通常也很熟悉诸如&lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;rm&lt;/code&gt;、&lt;code&gt;cp&lt;/code&gt;等一些文件操作工具，当浏览&lt;code&gt;/bin&lt;/code&gt;目录时，你会发现Ubuntu还有许多工具软件，本文将向读者简单介绍18个在Ubuntu上使用的命令行工具软件，本文不会详细介绍每个命令的用法，有对某个命令感兴趣的读者可以自行查找更详细的资料或者使用man在线手册，本文非常适合初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在ubuntu上检查内存使用情况的九种方法</title>
      <link>https://whowin.gitee.io/post/blog/linux/0027-how-to-check-ram-usage-in-ubuntu/</link>
      <pubDate>Tue, 09 Jan 2024 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0027-how-to-check-ram-usage-in-ubuntu/</guid>
      <description>&lt;p&gt;在 Ubuntu 中，可以通过 GUI(图形用户界面)和命令行使用多种方法来监视系统的内存使用情况，监视 Ubuntu 服务器上的内存使用情况并不复杂；了解已使用和可用的内存量对于故障排除和优化服务器性能至关重要，因为内存对系统 I/O 速度至关重要，定期监控内存使用情况有助于诊断潜在的系统问题和优化服务器性能，还可以帮助使用者确定是否需要扩充内存；本文将简要描述在 Ubuntu 上使用命令和工具监视内存使用情况的各种方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>D-Bus的标准接口、自省机制和服务接口的具体实现方法</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0026-standard-and-service-interfaces/</link>
      <pubDate>Mon, 08 Jan 2024 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0026-standard-and-service-interfaces/</guid>
      <description>&lt;p&gt;D-Bus的规范中提供了一系列的标准接口，绝大多数有D-Bus接口的系统调用都会实现这些标准接口，这些标准接口中包括D-Bus的自省(Introspection)机制，自省机制可以让我们通过一个标准接口了解一个D-Bus服务的各种方法的调用方法，本文将介绍D-Bus的这些标准接口及实现方式，同时也会介绍如何在D-Bus上提供自有服务，本文附有完整的实例和完整的源代码；本文实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文不适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之十五：使用libdbus通过D-Bus请求系统调用实现任意DNS记录解析的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0025-resolve-arbitrary-dns-record/</link>
      <pubDate>Thu, 28 Dec 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0025-resolve-arbitrary-dns-record/</guid>
      <description>&lt;p&gt;关于D-Bus的文章中曾介绍了如何通过D-Bus调用系统服务从而实现解析出一个域名的IP地址的过程，本文我们继续调用系统调用来实现解析任意DNS记录，系统调用的方法与前一篇文章类似，只是方法名称和调用参数以及返回参数不同，本文将详细介绍systemd-resolved服务中的ResolveRecord方法，同前面几篇关于D-BUS的文章相同，本文将使用 libdbus 库实现系统服务的调用，本文给出了实现解析任意DNS记录的实例，附有完整的源代码；本文实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文不适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之十四：使用libdbus通过select()接收D-Bus消息的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0024-select-recv-message/</link>
      <pubDate>Mon, 25 Dec 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0024-select-recv-message/</guid>
      <description>&lt;p&gt;在『进程间通信』系列文章中前面已经有三篇关于D-Bus的文章，本文继续讨论D-Bus；libdbus抽象了实现IPC时实际使用的方式(管道、socket等)，libdbus允许在一个D-Bus连接上添加一个watch，通过watch对实际IPC中使用的文件描述符进行监视，本文讨论了如何在D-Bus连接中添加watch，如何使用在socket编程中常用的select从D-Bus返回的文件描述符中接收到D-Bus消息，本文给出了具体实例，附有完整的源代码；本文实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文不适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之十三：使用libdbus通过D-Bus请求系统调用实现域名解析的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0023-dbus-resolve-hostname/</link>
      <pubDate>Sun, 10 Dec 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0023-dbus-resolve-hostname/</guid>
      <description>&lt;p&gt;前面两篇有关 D-Bus 的文章介绍了使用 libdbus 库进行进程间的方法调用和信号的传输，实际上 D-Bus 的更强大的地方是其建立了与大量系统服务之间建立了有效的对话规范，使得应用程序可以使用标准的方式调用系统服务的方法，访问系统服务中的一些开放的属性，本文将使用 libdbus 库调用系统服务中的方法从而实现域名解析，本文给出了实现该功能的实例，附有完整的源代码；本文实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文不适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之十二：使用libdbus在D-Bus上异步发送/接收信号的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0022-dbus-asyn-process-signal/</link>
      <pubDate>Wed, 06 Dec 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0022-dbus-asyn-process-signal/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本 IPC 系列文章的前十篇介绍了几乎所有的常用的 IPC 方法，每种方法都给出了具体实例，前面的文章里介绍了 D-Bus 的基本概念以及调用远程方法的实例，本文介绍 D-Bus 的异步处理机制，以及信号处理的基本方法，本文给出了异步处理 D-Bus 的实例，附有完整的源代码；本文实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文不适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之十一：使用D-Bus实现客户端向服务端请求服务的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0021-ipc-using-dbus/</link>
      <pubDate>Fri, 01 Dec 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0021-ipc-using-dbus/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本 IPC 系列文章的前十篇介绍了几乎所有的常用的 IPC 方法，每种方法都给出了具体实例，本文介绍在 Linux 下 IPC 的另外一种实现，D-Bus，D-Bus 是一种用于进程间通信的消息总线系统，它提供了一个可靠且灵活的机制，使得不同进程之间能够相互通信，本文给出了使用 D-Bus 进行基本 IPC 的实例，并附有完整的源代码；本文实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文不适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之十：使用共享文件进行进程间通信的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0020-ipc-using-files/</link>
      <pubDate>Mon, 06 Nov 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0020-ipc-using-files/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，常用的 IPC 方式有管道、消息队列、共享内存等，但其实使用广大程序员都熟悉的文件也是可以完成 IPC 的，本文介绍如何使用共享文件实现进程间通信，本文给出了具体的实例，并附有完整的源代码；本文实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文的实例中涉及多进程编程、文件锁等概念，所以对 Linux 编程的初学者有一些难度，但对于了解 Linux 下共享文件，特别是文件锁的应用，将是非常难得的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之九：使用UNIX Domain Socket进行进程间通信的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0019-ipc-with-unix-domain-socket/</link>
      <pubDate>Mon, 16 Oct 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0019-ipc-with-unix-domain-socket/</guid>
      <description>&lt;p&gt;socket 编程是一种用于网络通信的编程方式，在 socket 的协议族中除了常用的 AF_INET、AF_RAW、AF_NETLINK等以外，还有一个专门用于 IPC 的协议族 AF_UNIX，IPC 是 Linux 编程中一个重要的概念，常用的 IPC 方式有管道、消息队列、共享内存等，本文主要介绍用于本地进程间通信的 UNIX Domain Socket，本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文的实例中涉及多进程编程等，本文对 Linux 编程的初学者有一些难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之八：使用 POSIX 共享内存进行进程间通信的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0018-posix-shared-memory/</link>
      <pubDate>Wed, 27 Sep 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0018-posix-shared-memory/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍共享内存(Shared Memory)，因为没有像管道、消息队列这样的中介介入，所以通常认为共享内存是迄今为止最快的 IPC 方式；Linux 既支持 UNIX SYSTEM V 的共享内存段，也支持 POSIX 的共享内存对象，本文针对 POSIX 共享内存对象，本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文的实例中涉及多进程编程和信号处理等，阅读本文还需要一些基本的内存管理知识，本文对 Linux 编程的初学者有一些难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之七：使用 System V 共享内存段进行进程间通信的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0017-systemv-shared-memory/</link>
      <pubDate>Tue, 12 Sep 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0017-systemv-shared-memory/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍共享内存(Shared Memory)，因为没有像管道、消息队列这样的中介介入，所以通常认为共享内存是迄今为止最快的 IPC 方式；Linux 既支持 UNIX SYSTEM V 的共享内存，也支持 POSIX 的共享内存，本文针对 System V 共享内存段，本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文的实例中涉及多进程编程和信号处理等，阅读本文还需要一些基本的内存管理知识，本文对 Linux 编程的初学者有一些难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之六：使用 POSIX 信号量解决经典的&#39;生产者-消费者问题&#39;</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0016-posix-semaphores/</link>
      <pubDate>Wed, 06 Sep 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0016-posix-semaphores/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍信号量(Semaphores)，尽管信号量被认为是 IPC 的一种方式，但实际上通常把信号量用于进程间同步或者资源互斥，和共享内存(Shared Memory)配合使用，可以实现完美的进程间通信；Linux 既支持 UNIX SYSTEM V 的信号量集，也支持 POSIX 的信号量，本文针对 POSIX 信号量，本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文的实例中涉及多线程编程和信号处理等，对 Linux 编程的初学者有一些难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之五：使用 System V 信号量集解决经典的&#39;哲学家就餐问题&#39;</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0015-systemv-semaphore-sets/</link>
      <pubDate>Fri, 01 Sep 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0015-systemv-semaphore-sets/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍信号量集(Semaphore Sets)，尽管信号量集被认为是 IPC 的一种方式，但实际上通常把信号量集用于进程间同步或者资源访问互斥，信号量集和共享内存(Shared Memory)配合使用，可以实现完美的进程间通信；Linux 既支持 UNIX SYSTEM V 的信号量集，也支持 POSIX 的信号量集，本文仅针对 SYSTEM V 信号量集；本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文的实例中涉及多线程编程和信号处理等，对 Linux 编程的初学者有一些难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之四：使用 POSIX 消息队列进行进程间通信的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0014-posix-message-queue/</link>
      <pubDate>Sun, 20 Aug 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0014-posix-message-queue/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍消息队列(Message Queues)，消息队列可以完成同一台计算机上的进程之间的通信，相比较管道，消息队列要复杂一些，但使用起来更加灵活和方便，Linux 既支持 UNIX SYSTEM V 的消息队列，也支持 POSIX 的消息队列，本文针对 POSIX 消息队列，POSIX 标准引入了一个简单的基于文件的接口，使应用程序可以轻松地与消息队列进行交互；本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之三：使用 System V 消息队列进行进程间通信的实例</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0013-systemv-message-queue/</link>
      <pubDate>Sat, 05 Aug 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0013-systemv-message-queue/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍消息队列(Message Queues)，消息队列可以完成同一台计算机上的进程之间的通信，相比较管道，消息队列要复杂一些，但使用起来更加灵活和方便，Linux 既支持 UNIX SYSTEM V 的消息队列，也支持 POSIX 的消息队列，本文针对 System V 消息队列，并给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之二：使用命名管道(FIFO)进行进程间通信的例子</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0011-ipc-examples-of-fifo/</link>
      <pubDate>Wed, 02 Aug 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0011-ipc-examples-of-fifo/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍命名管道(FIFO)，命名管道可以完成同一台计算机上的进程之间的通信，本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文适合 Linux 编程的初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC之一：使用匿名管道进行父子进程间通信的例子</title>
      <link>https://whowin.gitee.io/post/blog/ipc/0010-ipc-example-of-anonymous-pipe/</link>
      <pubDate>Fri, 28 Jul 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/ipc/0010-ipc-example-of-anonymous-pipe/</guid>
      <description>&lt;p&gt;IPC 是 Linux 编程中一个重要的概念，IPC 有多种方式，本文主要介绍匿名管道(又称管道、半双工管道)，尽管很多人在编程中使用过管道，但一些特殊的用法还是鲜有文章涉及，本文给出了多个具体的实例，每个实例均附有完整的源代码；本文所有实例在 Ubuntu 20.04 上编译测试通过，gcc版本号为：9.4.0；本文适合 Linux 编程的初学者阅读&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用ioctl扫描wifi信号获取AP的essid、mac地址等属性</title>
      <link>https://whowin.gitee.io/post/blog/network/0022-how-to-scan-wifi-signal/</link>
      <pubDate>Mon, 26 Jun 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0022-how-to-scan-wifi-signal/</guid>
      <description>&lt;p&gt;使用 wifi 是一件再平常不过的是事情，有很多 wifi 工具可以帮助你扫描附近的 wifi 信号，测试信号强度等，但如何通过编程来操作 wifi 却鲜有文章涉及；本文立足实践，不使用任何第三方库，仅使用 ioctl 扫描附近的 wifi 信号，并获取这些 AP 的 ESSID、MAC 地址、占用信道和工作频率，本文将给出完整的源程序，今后还会写一些文章讨论如果编程获取 wifi 信号的其它属性(比如：信号强度、加密方式等)的方法，敬请关注；本文程序在 ubuntu 20.04 下编译测试完成，gcc 版本号 9.4.0；阅读本文并不需要对 IEEE802.11 协议有所了解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用C语言实现的一个DNS客户端</title>
      <link>https://whowin.gitee.io/post/blog/network/0019-dns-client-in-c/</link>
      <pubDate>Tue, 28 Mar 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0019-dns-client-in-c/</guid>
      <description>&lt;p&gt;DNS可以帮助我们把域名映射到一个IP地址上，或者查询一个IP地址下有那些域名，使用域名访问一个网站或者服务器是一件很平常的事情，很少有人关心域名变成IP地址的实际过程，本文将使用C语言实现一个基本的DNS解析器，通过与DNS服务器的通信完成将一个域名转换成IP地址的过程，本文将提供完整的源程序；阅读本文需要有一定的网络编程基础，熟悉基本的socket编程并对DNS有一些了解，本文对网络编程的初学者难度较大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用SOCK_DGRAM类型的socket实现的ping程序</title>
      <link>https://whowin.gitee.io/post/blog/network/0020-implement-ping-program-with-sock-dgram/</link>
      <pubDate>Thu, 16 Mar 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0020-implement-ping-program-with-sock-dgram/</guid>
      <description>&lt;p&gt;SOCK_DGRAM类型的socket常用于UDP通信，本文将尝试把这种socket用于ICMP协议，并完成一个简单的ping程序。使用ping去测试某个主机是否可用可能是一件很平常的事，尽管ping非常普通，但是编写一个实现ping功能的程序却并不是那么简单，因为ping使用的ICMP协议并不是一个应用层协议，在网上看到的实现ping的例子大多使用raw socket去实现，不仅增加了解析IP报头的麻烦，而且还需要有root权限才能运行，本文简要介绍ICMP协议，并给出一个使用普通的常用于UDP通信的socket实现ping的实例，本文将提供完整的源程序，本文的程序在 Ubuntu 20.04 下测试通过，gcc 版本号 9.4.0；阅读本文需要熟悉socket编程，对初学者而言，本文有一定的难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用tun虚拟网络接口建立IP隧道的实例</title>
      <link>https://whowin.gitee.io/post/blog/network/0018-tun-example-for-setting-up-ip-tunnel/</link>
      <pubDate>Tue, 07 Mar 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0018-tun-example-for-setting-up-ip-tunnel/</guid>
      <description>&lt;p&gt;通常的socket编程，面对的都是物理网卡，Linux下其实很容易创建虚拟网卡；本文简单介绍一下Linux虚拟网卡的概念，并以tun设备为例在客户端和服务器端分别建立一个实际的虚拟网卡，最终实现一个从客户端到服务器的简单的IP隧道，希望本文能对理解虚拟网卡和IP隧道有所帮助，本文将提供完整的源程序；阅读本文需要具备在Linux下使用C语言进行IPv4下socket编程的基本能力，本文对网络编程的初学者难度较大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用SNTP协议从时间服务器同步时间</title>
      <link>https://whowin.gitee.io/post/blog/network/0017-sync-time-from-time-server-using-sntp/</link>
      <pubDate>Mon, 13 Feb 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0017-sync-time-from-time-server-using-sntp/</guid>
      <description>&lt;p&gt;在互联网上校准时间，是几乎连接在互联网上的每台计算机都要去做的事情，而且很多是在后台完成的，并不需要人工干预；互联网上有很多时间服务器可以发布精确的时间，计算机客户端使用NTP(Network Time Protocol)协议与这些时间服务器进行时间同步，使本机得到精确时间，本文简要描述了NTP协议的原理，对NTP协议的时间同步精度做了简要分析，并具体实现了SNTP(Simple Network Time Protocol)下的客户端，本文附有完整的C语言SNTP客户端的源程序。阅读本文只需掌握基本的socket编程即可，本文对网络编程的初学者难度不大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>简单的路由表查找程序</title>
      <link>https://whowin.gitee.io/post/blog/network/0016-longest-prefix-match/</link>
      <pubDate>Fri, 10 Feb 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0016-longest-prefix-match/</guid>
      <description>&lt;p&gt;在Linux操作系统中，内核中有一个路由表，它包含若干条路由记录，这些记录由子网IP、子网掩码、网关IP和接口名等组成，这些信息用于将数据包转发到其他子网或者连接到互联网；本文介绍了当需要转发数据包时，Linux内核查找路由表的基本算法，并用程序模拟了这个过程，附有完整的源代码。本文对网络编程的初学者难度不大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用raw socket发送magic packet</title>
      <link>https://whowin.gitee.io/post/blog/network/0015-send-magic-packet-via-raw-socket/</link>
      <pubDate>Thu, 09 Feb 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0015-send-magic-packet-via-raw-socket/</guid>
      <description>&lt;p&gt;Magic Packet是进行网络唤醒的数据包，将这个数据包以广播的形式发到局域网上，与数据包中所关联的MAC相同的电脑就会被唤醒开机，通常我们都是使用UDP报文的形式来发送这个数据包，但实际上在进行网络唤醒的时候，只要报文中包含Magic Packet应该就可以唤醒相关的计算机，与IP协议、UDP协议没有任何关系，本文将试图抛开网络层(IP层)和传输层(TCP/UDP层)，直接在数据链路层发出Magic Packet，并成功实现网络唤醒，本文将提供完整的源代码。阅读本文需要有较好的网络编程基础，本文对网络编程的初学者有一定难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>从proc文件系统中获取gateway的IP地址</title>
      <link>https://whowin.gitee.io/post/blog/network/0008-get-gateway-ip-from-proc-filesys/</link>
      <pubDate>Sun, 05 Feb 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0008-get-gateway-ip-from-proc-filesys/</guid>
      <description>&lt;p&gt;在linux的命令行下获取当前网络环境的gateway的IP并不是一件难事，常用的命令有&lt;code&gt;ip route&lt;/code&gt;或者&lt;code&gt;route -n&lt;/code&gt;，&lt;code&gt;route -n&lt;/code&gt;是通过读取proc文件系统下的文件来从内核获取路由表的，但&lt;code&gt;ip route&lt;/code&gt;是通过netlink来获取的路由表；本文将讨论如何编写程序从proc文件系统中获取路由表，并从路由表中获取gateway的IP地址，文章最后给出了完整的源程序，本文对初学者基本没有难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>linux下使用netlink获取gateway的IP地址</title>
      <link>https://whowin.gitee.io/post/blog/network/0009-get-gateway-ip-via-netlink/</link>
      <pubDate>Sat, 04 Feb 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0009-get-gateway-ip-via-netlink/</guid>
      <description>&lt;p&gt;要在linux下的程序中获取gateway的IP地址，使用netlink是一种直接、可靠的方法，不需要依赖其它命令，直接从linux内核获取信息，netlink编程的中文资料很少，本文试图用尽可能简单的方式讨论使用netlink获取gataway的IP地址的编程方法，并有大量篇幅介绍netlink的相关数据结构和编程方法，阅读本文需要对linux下编程有一定了解，熟悉IPv4的socket编程；本文对网络编程的初学者有较大难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>接收arp请求并发送回应的实例</title>
      <link>https://whowin.gitee.io/post/blog/network/0007-recv-arp-request-and-reply/</link>
      <pubDate>Thu, 12 Jan 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0007-recv-arp-request-and-reply/</guid>
      <description>&lt;p&gt;ARP协议在网络编程中有着重要的地位，是一个工作在数据链路层的协议，本文简单介绍了ARP协议，用一个实例查看收到的ARP请求，并对该请求发出ARP回应，实例有完整的源代码，使用C语言在Linux下实现，代码中有详细的注释；阅读本文需要有一定的网络编程基础，了解OSI的网络模型，本文对初学者有一定的难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何用C语言操作arp cache</title>
      <link>https://whowin.gitee.io/post/blog/network/0014-handling-arp-cache/</link>
      <pubDate>Thu, 12 Jan 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0014-handling-arp-cache/</guid>
      <description>&lt;p&gt;arp cache中存放着局域网内IP地址和MAC地址的对应关系，对socket通信是至关重要的，arp cache由Linux内核进行维护，本文介绍如何用ioctl获取arp cache记录，添加新记录到arp cache中，删除arp cache中记录，每一种操作均给出了完整的源程序，本文程序在ubuntu 20.4中编译运行成功，gcc版本9.4.0，阅读本文需要有基本的socket编程和ioctl的知识，并对ARP协议有所了解，本文对网络编程的初学者难度不大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TCP服务器如何使用select处理多客户连接</title>
      <link>https://whowin.gitee.io/post/blog/network/0011-handling-multiple-clients-on-server-with-select/</link>
      <pubDate>Mon, 09 Jan 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0011-handling-multiple-clients-on-server-with-select/</guid>
      <description>&lt;p&gt;TCP是一种面向连接的通信方式，一个TCP服务器难免会遇到同时处理多个用户的连接请求的问题，本文用一个简化的实例说明如何在一个TCP服务器程序中，使用select处理同时出现的多个客户连接，文章给出了程序源代码，阅读本文应该具备了基本的socket编程知识，熟悉基本的服务器/客户端模型架构；本文对初学者难度不大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用select实现的UDP/TCP组合服务器</title>
      <link>https://whowin.gitee.io/post/blog/network/0010-tcp-and-udp-server-using-select/</link>
      <pubDate>Sat, 07 Jan 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0010-tcp-and-udp-server-using-select/</guid>
      <description>&lt;p&gt;独立的 TCP 服务器和UDP服务器，可以找到很多例子，但如果一个服务希望在同一个端口上既提供 TCP 服务，也提供 UDP 服务，写两个服务端显然不是一个好的办法，也不利于以后的维护，本文将把UDP服务器和 TCP 服务器合并成一个服务器，该服务器既可以提供 UDP 服务也可以提供 TCP 服务，本文将给出完整的源代码，阅读本文需要掌握基本的 socket 编程方法，本文对初学者难度不大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用C语言实现服务器/客户端的TCP通信</title>
      <link>https://whowin.gitee.io/post/blog/network/0012-tcp-server-client-implementation-in-c/</link>
      <pubDate>Fri, 06 Jan 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0012-tcp-server-client-implementation-in-c/</guid>
      <description>&lt;p&gt;本文力求使用简单的描述说明一个服务器/客户端TCP通信的基本程序框架，使读者在这个框架下可以构建更加复杂的服务，文中给出了服务器端和客户端的实例源程序，本文适合网络编程的初学者阅读；本文的程序在ubuntu 20.04中编译运行成功，gcc版本号为：9.4.0&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用C语言实现服务器/客户端的UDP通信</title>
      <link>https://whowin.gitee.io/post/blog/network/0013-udp-server-client-implementation-in-c/</link>
      <pubDate>Thu, 05 Jan 2023 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0013-udp-server-client-implementation-in-c/</guid>
      <description>&lt;p&gt;本文旨在使用简单的例子说明编写一个服务器/客户端模式的UDP通信程序的步骤，并通过一个实例给出了程序的基本框架，使读者可以在这个框架下经过扩展构建出更加复杂的服务，本文适合网络通信的初学者阅读；本文的程序在ubuntu 20.04中编译运行成功，gcc版本号为：9.4.0&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何使用raw socket发送UDP报文</title>
      <link>https://whowin.gitee.io/post/blog/network/0006-send-udp-with-raw-socket/</link>
      <pubDate>Tue, 27 Dec 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0006-send-udp-with-raw-socket/</guid>
      <description>&lt;p&gt;使用raw socket发送报文比接收报文要复杂一些，因为需要在程序中构建数据链路层、网络层和传输层的报头，本文以发送UDP报文为例说明在使用raw socket时如何构建数据链路层、网络层和传输层的报头并发送报文，文中给出了完整的源程序；阅读本文需要掌握基本的IPv4下的socket编程方法，本文对初学者有一定难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何计算IP报头的checksum</title>
      <link>https://whowin.gitee.io/post/blog/network/0004-checksum-of-ip-header/</link>
      <pubDate>Wed, 14 Dec 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0004-checksum-of-ip-header/</guid>
      <description>&lt;p&gt;如果你研究过TCP/IP协议，那么你肯定知道IP报头中的checksum字段，或许你还曾经为如何计算这个字段的值所困扰，本文我们将讨论checksum的概念，并详细介绍IP报头中的checksum是如何计算的，本文适合初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何计算UDP头的checksum</title>
      <link>https://whowin.gitee.io/post/blog/network/0003-checksum-of-udp-header/</link>
      <pubDate>Mon, 12 Dec 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0003-checksum-of-udp-header/</guid>
      <description>&lt;p&gt;UDP报头只有4个字段，分别是：源端口号、目的端口号、报文长度和报头checksum，其中的报头checksum这个字段在IPv4中并不是强制的，但在IPv6中是强制的，本文介绍UDP报头中checksum的计算方法，并给出相应的源程序，实际上，网络通信中常用的IP报头、TCP报头和UDP报头中都有checksum，其计算方法基本一样，所以把这些检查和一般统称为Internet Checksum；本文对网络编程的初学者难度不大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何在Linux命令行下发送和接收UDP数据包</title>
      <link>https://whowin.gitee.io/post/blog/network/0005-send-udp-via-linux-cli/</link>
      <pubDate>Sat, 10 Dec 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0005-send-udp-via-linux-cli/</guid>
      <description>&lt;p&gt;众所周知，在传输层有两个常用的协议 TCP 和 UDP，本文介绍在 Linux 命令行下，如何使用 nc 命令发送或接收 UDP 数据包，这些命令的用法对调试 UDP 通信程序将有所帮助，本文适合初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux下如何在数据链路层接收原始数据包</title>
      <link>https://whowin.gitee.io/post/blog/network/0002-link-layer-programming/</link>
      <pubDate>Wed, 07 Dec 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0002-link-layer-programming/</guid>
      <description>&lt;p&gt;大多数的网络编程都是在应用层接收数据和发送数据的，程序员无需关注报文的各种报头，网络协议栈会解决这些问题，本文介绍在数据链路层的网络编程方法，介绍如何在数据链路层直接接收从物理层发过来的原始数据包，要得到数据，必须自己解开数据链路层、网络层和传输层的报头，文章给出了一个完整的范例程序，希望本文能帮助读者对网络通信有更深刻的理解；阅读本文需要具备基本的使用socket进行网络编程的能力，熟悉OSI的网络模型，本文对初学者有一定的难度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言获取ipv6地址的三种方法</title>
      <link>https://whowin.gitee.io/post/blog/network/0001-how-to-get-ipv6-in-c/</link>
      <pubDate>Sun, 16 Oct 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/network/0001-how-to-get-ipv6-in-c/</guid>
      <description>&lt;p&gt;使用通常获取ipv4的IP地址的方法是无法获取ipv6地址的，本文介绍了使用C语言获取ipv6地址的三种方法：从proc文件从系统获取ipv6地址、使用getifaddrs()函数获取ipv6地址和使用netlink获取ipv6地址，每种方法均给出了完整的源程序，本文所有实例在 ubuntu 20.04 下测试通过，gcc 版本 9.4.0；阅读本文需要有一定的网络编程基础知识和IPv6的知识。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C语言函数调用时的参数传递机制</title>
      <link>https://whowin.gitee.io/post/blog/c/0001-parameters-passing-mechanism/</link>
      <pubDate>Tue, 20 Sep 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/c/0001-parameters-passing-mechanism/</guid>
      <description>&lt;p&gt;本文通过实例验证了 C 语言函数调用时参数传递机制在 32 位和 64 位时的不同；阅读本文不仅需要 C 语言的知识，还需要有一些汇编语言的知识。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux文件权限：setuid、setgid和sticky bit</title>
      <link>https://whowin.gitee.io/post/blog/linux/0012-setuid/</link>
      <pubDate>Thu, 25 Aug 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0012-setuid/</guid>
      <description>&lt;p&gt;Linux 下的文件权限管理分为三组：拥有者、组、其它用户，文件权限分为读、写、执行，但其实并不仅仅如此，还有 setuid、setgid、sticky bit 这一组标志，本文通过一个可执行文件的权限 4755 展开介绍 setuid、setgid 和 sticky bit 的概念，希望本文对读者理解 Linux 文件权限管理能有所帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>远程开机：一个简单的嵌入式项目开发</title>
      <link>https://whowin.gitee.io/post/blog/embedded/0001-wake-on-lan/</link>
      <pubDate>Thu, 18 Aug 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/embedded/0001-wake-on-lan/</guid>
      <description>&lt;p&gt;本文通过一个简单的需求介绍了在一个 &lt;em&gt;ARM&lt;/em&gt; 设备上开发一个程序实现远程打开服务器的过程，通过这个实例大致介绍了一个简单的嵌入式 &lt;em&gt;Linux&lt;/em&gt; 开发的过程。本文并不会详细介绍网络唤醒的原理以及 &lt;em&gt;Magic Packet&lt;/em&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>apt update是如何工作的</title>
      <link>https://whowin.gitee.io/post/blog/linux/0008-apt-update-ubuntu/</link>
      <pubDate>Sun, 10 Jul 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0008-apt-update-ubuntu/</guid>
      <description>&lt;p&gt;本文简单介绍了在ubuntu的命令行下运行 &lt;code&gt;apt update&lt;/code&gt; 时，软件包管理工具 apt 所执行的实际动作，相信此文会让你对 ubuntu 的包管理系统有更好的了解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>安装一个好用的Ubuntu桌面</title>
      <link>https://whowin.gitee.io/post/blog/linux/0007-ubuntu-desktop/</link>
      <pubDate>Fri, 06 May 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0007-ubuntu-desktop/</guid>
      <description>&lt;p&gt;Ubuntu 桌面是 Linux 发行版中比较流行的桌面；Ubuntu 是开放源代码的自由软件，用户可以从 Ubuntu 官网上免费下载 Ubuntu 的安装包；本文只是记录了安装一个 Ubuntu 桌面及其应用环境的全过程，本文正是在这个环境中写成，谨此希望对准备使用 Ubuntu 桌面的朋友们有所帮助；本文适合 Linux 的初学者。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>bash下变量PS1的完整理解</title>
      <link>https://whowin.gitee.io/post/blog/linux/0004-setup-ps1/</link>
      <pubDate>Mon, 18 Apr 2022 13:30:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0004-setup-ps1/</guid>
      <description>&lt;p&gt;本文并不会讲解如何设置PS1以获得你喜欢的提示符；本文会围绕PS1这个变量，就其涉及到的一些概念展开讨论&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>bash 的环境变量和 shell 变量</title>
      <link>https://whowin.gitee.io/post/blog/linux/0001-environment-variables-and-shell-variables/</link>
      <pubDate>Sun, 10 Apr 2022 16:43:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0001-environment-variables-and-shell-variables/</guid>
      <description>&lt;p&gt;本文简单介绍了 bash 的启动过程；shell 变量和环境变量的区别及相互转换；环境变量传递给子进程的过程；在当前环境下执行脚本及其实际应用，本文适合 Linux 初学者。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ANSI的ESC转义序列</title>
      <link>https://whowin.gitee.io/post/blog/linux/0003-ansi-escape-code/</link>
      <pubDate>Wed, 06 Apr 2022 14:00:00 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0003-ansi-escape-code/</guid>
      <description>&lt;p&gt;本文较完整第介绍了ANSI的转义序列，大多数都可以用于在普通终端上显示出较为漂亮的界面，本文可以作为一个资料备查。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Getting Start</title>
      <link>https://whowin.gitee.io/getting-start/getting-start/</link>
      <pubDate>Mon, 04 Apr 2022 11:52:02 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/getting-start/getting-start/</guid>
      <description>Getting start 这是一个测试页面</description>
    </item>
    
    <item>
      <title>完整的PS1控制码</title>
      <link>https://whowin.gitee.io/post/blog/linux/0002-ps1-control-codes/</link>
      <pubDate>Fri, 01 Apr 2022 14:00:00 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/linux/0002-ps1-control-codes/</guid>
      <description>&lt;p&gt;PS1变量是在 shell 下用于定义提示符的变量，本文列出了可用于该变量的所有的控制代码，仅供参考.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://whowin.gitee.io/about/about/</link>
      <pubDate>Fri, 01 Apr 2022 11:51:22 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/about/about/</guid>
      <description>个人介绍 85年底开始有幸接触到IBM PC，开始学习使用BASIC、86汇编编程，一晃已过35年以上 36年的职业历程，终于可以退休，不再朝九晚</description>
    </item>
    
    <item>
      <title>在vitual box虚拟机上安装dos</title>
      <link>https://whowin.gitee.io/post/blog/dos/0014-install-dos-on-vbox-under-ubuntu/</link>
      <pubDate>Tue, 23 Apr 2013 14:27:38 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0014-install-dos-on-vbox-under-ubuntu/</guid>
      <description>&lt;p&gt;现在找一台运行DOS的机器可是太不容易了，如果想玩DOS，只有在虚拟机上安装了，本文介绍如何在Virtual Box虚拟机上安装dos 6.22，本文的实例是在Ubuntu下，在windows基本也是一样的。本文适合初学者阅读。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>给Allegro增加一个JPEG库</title>
      <link>https://whowin.gitee.io/post/blog/dos/0013-install-jpgalleg-for-allegro-under-djgpp/</link>
      <pubDate>Thu, 15 May 2008 11:42:58 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0013-install-jpgalleg-for-allegro-under-djgpp/</guid>
      <description>&lt;p&gt;Allegro本身不能对jpeg图片进行处理，比如把生成的图形存储成jpeg文件，所以给Allegro配上一个合适的jpeg库是很有必要的，本文详细介绍了如何在Allegro上安装一个叫做jpgalleg的jpeg库。&lt;strong&gt;本文是我2008年的作品，2023年重新整理发布，仅为存档，其中的程序并没有再次验证，特此说明。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在DJGPP&#43;DOS下安装ALLEGRO</title>
      <link>https://whowin.gitee.io/post/blog/dos/0012-install-allegro-under-dos-djgpp/</link>
      <pubDate>Wed, 14 May 2008 17:10:29 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0012-install-allegro-under-dos-djgpp/</guid>
      <description>&lt;p&gt;Allegro是一个用于编写游戏和多媒体程序的库，我发现它时是在2008年，但其实它的诞生可能要追溯到2000年以前了，当时我把它用在DOS+DJGPP的环境下，那是我当时能找到的在DOS下可以使用的为数不多的图像库之一，而且比较好用，本文主要介绍如何在DOS+DJGPP环境下安装ALLEGRO。&lt;strong&gt;本文是我2008年的作品，2023年重新整理发布，仅为存档，其中的程序并没有再次验证，特此说明。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DOS DPMI下的硬件中断机制</title>
      <link>https://whowin.gitee.io/post/blog/dos/0011-hw-int-mechanism-under-dos-dpmi/</link>
      <pubDate>Wed, 07 May 2008 17:45:03 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0011-hw-int-mechanism-under-dos-dpmi/</guid>
      <description>&lt;p&gt;本文旨在探讨DPMI(DOS Protect Mode Interface)环境下的硬件中断机制，以及在此环境下硬件中断的编写方法，本文并不探讨实模式下和保护模式下硬件中断的原理，但文中难免涉及一些这方面的知识，请读者自行阅读相关资料解决。在本文的最后将举一个硬件中断的编写实例。本文主要讨论的环境为：DOS6.22 + DJGPP + CWSDPMI。CWSDPMI为DJGPP自带的DPMI服务，也是一个好用的且免费的DPMI，有关这个环境的搭建，请参阅我以前的博文。&lt;strong&gt;本文是我2008年的作品，2023年重新整理发布，仅为存档，其中的程序并没有再次验证，特此说明。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在DOS下针对AC&#39;97编程</title>
      <link>https://whowin.gitee.io/post/blog/dos/0010-ac97-programing-in-dos/</link>
      <pubDate>Tue, 22 Apr 2008 14:52:57 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0010-ac97-programing-in-dos/</guid>
      <description>&lt;p&gt;AC&#39;97大多数应该听说过，可能有些人把它当成一种声卡，或者是声卡上的芯片等等，其实它仅仅是一种规范，符合AC&#39;97规范的声卡，通常叫做AC&#39;97声卡，但其实上面使用的芯片可能完全不一样。现在很多桥片中甚至已经集成了AC&#39;97的规范进去，就不需要专门的声卡了。本文针对AMD的较新的一种桥片CS5536上集成的AC&#39;97进行编程，进而说明如何对符合AC&#39;97规范的声卡进行编程。以下为书写方便，把AC&#39;97写成AC97。&lt;strong&gt;本文是我2008年的作品，2023年重新整理发布，仅为存档，其中的程序并没有再次验证，特此说明。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在DOS下进行网络编程（下）</title>
      <link>https://whowin.gitee.io/post/blog/dos/0008-network-programming-on-dos-2/</link>
      <pubDate>Fri, 11 Apr 2008 10:10:33 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0008-network-programming-on-dos-2/</guid>
      <description>&lt;p&gt;该文在上一篇文章的基础上，用一个完整的例子讲解在DOS下的网络编程方法&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在DOS下进行网络编程（上）</title>
      <link>https://whowin.gitee.io/post/blog/dos/0007-network-programming-on-dos-1/</link>
      <pubDate>Wed, 09 Apr 2008 10:06:26 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0007-network-programming-on-dos-1/</guid>
      <description>&lt;p&gt;该文介绍了在 DOS 下的进行网络编程的基本方法，该文写于2008年4月，2022年重新发表修了一些修改&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DOS的系统杂项服务INT 15H介绍</title>
      <link>https://whowin.gitee.io/post/blog/dos/0006-dos-int15h-introduction/</link>
      <pubDate>Fri, 04 Apr 2008 09:32:48 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0006-dos-int15h-introduction/</guid>
      <description>&lt;p&gt;该文介绍了 DOS 下的 int 15h 的功能，可以作为资料备查&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>遍历 PCI 设备</title>
      <link>https://whowin.gitee.io/post/blog/dos/0005-traverse-pci-devices/</link>
      <pubDate>Wed, 02 Apr 2008 09:15:23 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0005-traverse-pci-devices/</guid>
      <description>&lt;p&gt;PC机在启动的时候，都会看到一个PCI设备清单，可以看到机器中的所有PCI设备，其实搜索PCI设备的程序并不难编，本文通过一个实例说明如何遍历PCI设备。本文程序的工作环境：MS-DOS 6.22，djgpp+RHIDE。本文初次发表于2008年4月2日，2011年3月11日做过修改，将其中的代码片段换为完整代码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 DOS 下的 DJGPP &#43; RHIDE 安装实作</title>
      <link>https://whowin.gitee.io/post/blog/dos/0004-install-djgpp-rhide-under-dos/</link>
      <pubDate>Fri, 28 Mar 2008 13:48:41 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0004-install-djgpp-rhide-under-dos/</guid>
      <description>&lt;p&gt;本文介绍在一个纯DOS构建一个C、C++和汇编的保护模式开发环境，编写的程序可以在纯DOS环境下运行在保护模式下&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 DOS 下安装 DJGPP</title>
      <link>https://whowin.gitee.io/post/blog/dos/0003-djgpp-installation/</link>
      <pubDate>Thu, 27 Mar 2008 14:27:38 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0003-djgpp-installation/</guid>
      <description>&lt;p&gt;该文翻译自 &lt;strong&gt;djgpp version 2.03&lt;/strong&gt; 的 &lt;em&gt;.readme&lt;/em&gt; 文件。本文中包含获得、安装、使用 &lt;strong&gt;DJGPP&lt;/strong&gt; 的信息，在寻求帮助之前请完整阅读该文档。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>调用PCI BIOS</title>
      <link>https://whowin.gitee.io/post/blog/dos/0002-invoking-pci-bios/</link>
      <pubDate>Tue, 18 Mar 2008 15:10:28 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0002-invoking-pci-bios/</guid>
      <description>&lt;p&gt;通过执行INT 1AH指令可以调用16位的PCI BIOS，也可以直接在物理寄存器位置000FFE6EH调用PCI BIOS。32位BIOS的调用要通过一个远程调用来实现。在这两种情况下，调用这都必须首先将需要的请求参数装入处理器的寄存器组。在入口AH寄存器必须包含PCI的功能ID：B1H，AL寄存器必须包含PCI下级功能识别器。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>32位 BIOS 说明</title>
      <link>https://whowin.gitee.io/post/blog/dos/0001-32bit-bios-introduction/</link>
      <pubDate>Tue, 18 Mar 2008 13:15:48 +0800</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/0001-32bit-bios-introduction/</guid>
      <description>&lt;p&gt;PCI BIOS 在 PCI 编程中起着一定的作用，PCI BIOS 的资料也不是很好找，把找到的集中到这里，供参考。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/article-categories/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/article-categories/archives/</guid>
      <description>2023 01-12 如何用C语言操作arp cache 01-12 接收arp请求并发送回应的实例 01-09 TCP服务器如何使用select处理多客户连接 01-07 使用select实现的UDP/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/article-categories/categories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/article-categories/categories/</guid>
      <description>文章分类 1. 网络编程 这个专栏中的绝大多数文章中都会附有完整的、可编译运行的源代码，该专栏主要讨论在Linux下的socket编程，包括IPv4</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/post/blog/dos/2008-05-21cs5536%E4%B8%8A%E7%9A%84i2c%E6%80%BB%E7%BA%BF%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/2008-05-21cs5536%E4%B8%8A%E7%9A%84i2c%E6%80%BB%E7%BA%BF%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>CS5536上的I2C总线的应用 2008-05-21 13:28:41 以前我们使用AMD 的GX1搭配CS5530做主板，用的还比较顺手，后来AMD的GX1停产了，加上欧洲无铅</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/post/blog/dos/2008-05-23usb%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E5%88%97%E5%87%BA%E4%BD%A0%E7%9A%84usb%E8%AE%BE%E5%A4%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/2008-05-23usb%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E5%88%97%E5%87%BA%E4%BD%A0%E7%9A%84usb%E8%AE%BE%E5%A4%87/</guid>
      <description>USB系列之一：列出你的USB设备 2008-05-23 11:04:56 USB现在已经成为PC机必不可少的接口之一，几乎所有的设备都可以接在USB设备上，USB键盘、鼠标、打</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/post/blog/dos/2008-06-11usb%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E8%AF%BB%E5%8F%96usb%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/2008-06-11usb%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C%E8%AF%BB%E5%8F%96usb%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6/</guid>
      <description>USB系列之二：读取USB设备的描述符 2008-06-11 08:33:59 在前面的文章中，我们已经给出了USB协议的链接地址，从这篇文章起，我们会涉及到许多USB 1.1的内</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/post/blog/dos/2008-07-08usb%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E4%BB%8E%E4%BD%A0%E7%9A%84u%E7%9B%98%E9%87%8C%E8%AF%BB%E5%87%BA%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/2008-07-08usb%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%E4%BB%8E%E4%BD%A0%E7%9A%84u%E7%9B%98%E9%87%8C%E8%AF%BB%E5%87%BA%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>USB系列之三：从你的U盘里读出更多的内容 2008-07-08 23:02:42 U盘是我们最常使用的一种USB设备，本文继续使用DOSUSB做驱动，试图以读取扇区的方式读取你</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/post/blog/dos/2008-07-15usb%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9B%E5%90%91u%E7%9B%98%E4%B8%8A%E5%86%99%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/2008-07-15usb%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9B%E5%90%91u%E7%9B%98%E4%B8%8A%E5%86%99%E6%95%B0%E6%8D%AE/</guid>
      <description>USB系列之四：向U盘上写数据 2008-07-15 19:32:11 在《USB系列之三》中，我们实现了一系列的SCSI命令，在这个系列中，我们要实现向U盘上写扇区的命令，所以</description>
    </item>
    
    <item>
      <title></title>
      <link>https://whowin.gitee.io/post/blog/dos/2008-07-16%E5%88%86%E5%8C%BA%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://whowin.gitee.io/post/blog/dos/2008-07-16%E5%88%86%E5%8C%BA%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84/</guid>
      <description>分区信息表的结构 私人日志 2008-07-16 10:53:07 硬盘的0柱面、0磁头、1扇区称为主引导扇区，该扇区的内容称为主引导记录（Main Boot Record（MBR）），在M</description>
    </item>
    
  </channel>
</rss>
