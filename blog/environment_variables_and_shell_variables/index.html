<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>bash 的环境变量和 shell 变量 - whowin&#39;s blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="shell变量和环境变量相关的一些概念">
		<meta property="og:title" content="bash 的环境变量和 shell 变量" />
<meta property="og:description" content="shell变量和环境变量相关的一些概念" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://whowin.gitee.io/blog/environment_variables_and_shell_variables/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-04-10T16:43:29+08:00" />
<meta property="article:modified_time" content="2022-04-10T16:43:29+08:00" />


		<meta itemprop="name" content="bash 的环境变量和 shell 变量">
<meta itemprop="description" content="shell变量和环境变量相关的一些概念"><meta itemprop="datePublished" content="2022-04-10T16:43:29+08:00" />
<meta itemprop="dateModified" content="2022-04-10T16:43:29+08:00" />
<meta itemprop="wordCount" content="789">
<meta itemprop="keywords" content="shell,bash,source,printenv,环境变量,declare,export," />
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo logo--mixed">
		<a class="logo__link" href="/" title="whowin" rel="home">
			<div class="logo__item logo__imagebox">
					<img class="logo__img" src="/images/blog_logo.jpg">
				</div><div class="logo__item logo__text">
					<div class="logo__title">whowin</div>
					<div class="logo__tagline">whowin的个人技术博客</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/about/">
				
				<span class="menu__text">About me</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/blog/">
				
				<span class="menu__text">Article List</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">bash 的环境变量和 shell 变量</h1>
			<div class="post__meta meta"><div class="meta__item-author meta__item">
	<svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2 0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class="meta__text">whowin</span>
</div>
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2022-04-10T16:43:29&#43;08:00">2022-04-10</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg><span class="meta__text"><a class="meta__link" href="/categories/linux/" rel="category">Linux</a>, <a class="meta__link" href="/categories/shell/" rel="category">Shell</a>, <a class="meta__link" href="/categories/bash/" rel="category">Bash</a>
	</span>
</div></div>
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">目录</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#导言">导言</a></li>
    <li><a href="#终端是如何启动-shell-的">终端是如何启动 shell 的</a></li>
    <li><a href="#shell-变量和环境变量">shell 变量和环境变量</a></li>
    <li><a href="#bash-如何将环境变量传给子进程">bash 如何将环境变量传给子进程</a></li>
    <li><a href="#在当前环境下运行程序">在当前环境下运行程序</a></li>
    <li><a href="#结语">结语</a></li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<p>本文简单介绍了bash的启动过程；shell变量和环境变量的区别及相互转换；环境变量传递给子进程的过程；当前环境执行脚本机器实际应用</p>
<h2 id="导言">导言</h2>
<ul>
<li>
<p>shell 是一个 Linux 的命令行解释器，Linux 下有很多 shell，其中 ubuntu 中默认的 shell 是应该是 <strong>dash</strong>，因为我们看到 <em>/bin/sh</em> 被链接到了 <strong>dash</strong></p>
<p><img src="/images/100001/sh_point_to_dash.png" alt="/bin/sh&amp;ndash;&gt;dash"></p>
<p><strong>图1：/bin/sh指向dash</strong></p>
</li>
<li>
<p>但是当你启动终端时(不管是在桌面还是远程)，默认启动的却是 <strong>bash</strong>(Bourne-Again SHell)，bash 是 GNU (Gnu&rsquo;s Not Unix)开发的</p>
</li>
<li>
<p>使用 <em>cat /etc/shells</em> 命令可以看到在你的 Linux 下有那些 shell；使用 <em>echo $SHELL</em> 可以看到当前你正在使用的 shell</p>
</li>
<li>
<p>本文中如无特别说明，shell 指的是 bash，所有范例在 ubuntu 16.04 下完成，在更高版本的 ubuntu 上，可能会有些微区别；在较低版本的 ubuntu 上不能保证有相同的效果</p>
</li>
</ul>
<h2 id="终端是如何启动-shell-的">终端是如何启动 shell 的</h2>
<ul>
<li>
<p>ubuntu 的1号进程是 systemd，这是 ubuntu 在加载完 Linux 内核后启动的第一个进程，是所有其它进程的祖宗</p>
</li>
<li>
<p>你可能用 <em>ps aux(ps -ef)</em> 命令发现1号进程是 <strong>/sbin/init</strong>，而不是 <strong>systemd</strong>，但你用 <em>ls -l /sbin/init</em> 看一下就会恍然大悟</p>
<p><img src="/images/100001/first_process.png" alt="1号进程"></p>
<p><strong>图1：1号进程</strong></p>
<p><img src="/images/100001/init_point_to_systemd.png" alt="init进程指向systemd"></p>
<p><strong>图3：/sbin/init指向systemd</strong></p>
</li>
<li>
<p>当你在 ubuntu 桌面版上启动一个终端时，会启动一个 <strong>gnome-terminal</strong> 进程，gnome-terminal 进程启动了 <strong>bash</strong> 进程，这样你就看到可爱的提示符了，这个过程使用 <em>pstree</em> 命令一目了然</p>
<p><img src="/images/100001/terminal-bash.png" alt="gnome-terminal进程启动bash"></p>
<p><strong>图4：gnome-terminal进程启动bash</strong></p>
</li>
<li>
<p>当你使用 ssh 客户端远程登录到 Linux 系统时，<strong>bash</strong> 进程是由 <strong>sshd</strong> 进程启动的，这个也可以用 <em>pstree</em> 命令看到</p>
<p><img src="/images/100001/sshd-bash.png" alt="sshd进程启动bash"></p>
<p><strong>图5：sshd进程启动bash</strong></p>
</li>
<li>
<p>只有启动了 bash 你才拥有了一个 shell 环境，你才能够在终端上输入命令，你从键盘输入的任何内容都必须由 bash 进行解释并做出进一步的处理</p>
</li>
</ul>
<h2 id="shell-变量和环境变量">shell 变量和环境变量</h2>
<ul>
<li>
<p><strong>shell 变量</strong></p>
<ul>
<li>shell 管理着一个变量表，这使得用户可以自己定义变量，这些变量是在 shell 下建立，由 shell 管理，在 shell 下使用</li>
<li>在启动 shell(bash) 的时候，shell 会创建一些变量(不同的 shell 创建的变量会有所不同)，同时，shell 在启动过程中还会去执行一些可以由客户自定义的脚本，比如：在启动bash时会执行：<strong>/etc/bash.bashrc</strong>，在登录时会执行：<strong>~/.bashrc</strong>等，这些脚本通常也会建立一些变量</li>
<li>由于有些脚本是在用户登录时执行的，比如：<strong>~/.bashrc</strong>，而这个脚本是放在用户的 <strong>home</strong> 目录下的，这就使得不同的用户在登录时可以执行不同的脚本，从而每个用户在登录后所建立的 shell 变量也可以是不一样的</li>
<li>在 shell 下，可以直接用：<em>变量名=变量值</em> 的方法定义或修改 shell 变量；也可以用：<em>unset 变量名</em> 来删除变量，按照惯例，shell 变量名使用<strong>大写字母</strong></li>
<li>使用 <em>set</em> 命令可以查看当前所有的 shell 变量；用 <em>echo $变量名</em> 可以显示指定变量名的值</li>
</ul>
</li>
<li>
<p><strong>环境变量</strong></p>
<ul>
<li>环境变量也是 shell 变量，但环境变量却不等同于 shell 变量，我们暂时把不是环境变量的 shell 变量称作 <strong>普通 shell 变量</strong>，在 bash 内部，环境变量与普通 shell 变量的区别，仅仅是一个不同的标记而已</li>
<li>环境变量和普通 shell 变量的最主要的区别是，在建立一个子进程时，环境变量会被传递给这个子进程，而普通 shell 变量不会，所以，环境变量可能会对一个子进程的行为产生影响，因为子进程可以根据环境变量的值做出不同的动作</li>
<li>环境变量可以使用 <em>export 变量名=变量值</em> 进行设置，可以像普通 shell 变量一样用 <em>unset 变量名</em> 进行删除</li>
<li>可以使用 <em>printenv</em> 命令查看所有的环境变量；用 <em>echo $变量名</em> 可以显示指定环境变量的值；也可以用 <em>printenv 环境变量名</em> 来显示一个环境变量的值</li>
<li><em>env</em> 如果不带参数的话，也是可以显示环境变量的，但这个命令主要用于在指定环境下执行命令</li>
</ul>
</li>
<li>
<p>关于 <em>env</em> 命令的两个例子</p>
<ul>
<li><em>env 环境变量名=变量值 命令</em> 和 <em>env -u 环境变量名 命令</em> 都只能临时在一个新的环境中改变或者删除一个变量，用于在一个指定的环境中执行命令，这一点在很多文章中都没有明确说明</li>
<li>下面的例子设置了一个临时环境变量 <strong>ENV_VAR_1</strong>，并且在这个临时环境中将这个变量的值打印出来
<pre tabindex="0"><code>$ printenv ENV_VAR_1                           # 当前环境下，不存在环境变量 ENV_VAR_1
$ env ENV_VAR_1=first_value printenv ENV_VAR_1 # 临时设置环境变量并打印出值
first_value                                    # 临时设置的环境变量ENV_VAR_1的值
$ printenv ENV_VAR_1                           # 当前环境下，仍然不存在环境变量 ENV_VAR_1
$ 
</code></pre></li>
<li>下面的例子中在临时环境中删除一个在当前环境中存在的环境变量，在临时环境中打印该环境变量为空，确定该环境变量在临时环境中已经不存在
<pre tabindex="0"><code>$ export ENV_VAR_2=second_value                  # 当前环境下设置环境变量
$ printenv ENV_VAR_2                             # 打印该环境变量的值
second_value
$ env -u ENV_VAR_2 printenv SHELL ENV_VAR_2 USER # 临时删除该环境变量，并在临时环境中打印该变量
/bin/bash                                        # SHELL变量的值
demouser                                         # USER变量的值，偏偏没有变量ENV_VAR_2的值
$ printenv ENV_VAR_2                             # 当前环境下打印环境变量ENV_VAR_2
second_value
$ 
</code></pre></li>
</ul>
</li>
<li>
<p><strong>环境变量和普通shell变量的转换</strong></p>
<ul>
<li>普通shell变量，通过 <em>export 变量名</em> 可以转变成环境变量
<pre tabindex="0"><code>$ set|grep VAR_TO_ENVVAR                # 没有VAR_TO_ENVVAR这个shell变量
$ VAR_TO_ENVVAR=convert_var_to_envvar   # 设置VAR_TO_ENVVAR
$ set|grep VAR_TO_ENVVAR                # VAR_TO_ENVVAR是一个shell变量
VAR_TO_ENVVAR=convert_var_to_envvar
$ printenv|grep VAR_TO_ENVVAR           # VAR_TO_ENVVAR不是一个环境变量
$ export VAR_TO_ENVVAR                  # 执行export命令
$ printenv|grep VAR_TO_ENVVAR           # VAR_TO_ENVVAR已经变成一个环境变量
VAR_TO_ENVVAR=convert_var_to_envvar
$ 
</code></pre></li>
<li>普通shell变量，通过 <em>declare -x 变量名</em> 可以转变成环境变量
<pre tabindex="0"><code>$ unset VAR_TO_ENVVAR                   # 删除变量VAR_TO_ENVVAR
$ VAR_TO_ENVVAR=convert_var_to_envvar   # 设置VAR_TO_ENVVAR
$ set|grep VAR_TO_ENVVAR                # VAR_TO_ENVVAR是一个shell变量
VAR_TO_ENVVAR=convert_var_to_envvar
$ printenv|grep VAR_TO_ENVVAR           # VAR_TO_ENVVAR不是一个环境变量
$ declare -x VAR_TO_ENVVAR              # 执行declare命令
$ printenv|grep VAR_TO_ENVVAR           # VAR_TO_ENVVAR已经变成一个环境变量
VAR_TO_ENVVAR=convert_var_to_envvar
$ 
</code></pre></li>
<li>环境变量，通过 <em>declare +x 变量名</em> 可以转变成普通shell变量
<pre tabindex="0"><code>$ export ENV_VAR_1=testing    # 设置一个环境变量
$ printenv|grep ENV_VAR_1     # 确认设置成功
ENV_VAR_1=testing
$ declare +x ENV_VAR_1        # 执行declare +x命令
$ printenv|grep ENV_VAR_1     # 该变量已经不再是环境变量
$ set|grep ENV_VAR_1          # 该变量仍然是一个普通shell变量
ENV_VAR_1=testing
$ 
</code></pre></li>
<li><em>declare 变量名=变量值</em> 可以用来设置或修改一个普通shell变量的值；<em>declare -x 变量名=变量值</em> 可以用来设置或修改一个环境变量的值；<em>declare -x 变量名</em> 可以将普通shell变量变成环境变量；<em>declare +x 变量名</em> 可以将环境变量变成普通shell变量</li>
</ul>
</li>
</ul>
<h2 id="bash-如何将环境变量传给子进程">bash 如何将环境变量传给子进程</h2>
<ul>
<li><strong>bash 如何执行一个命令</strong>
<ul>
<li>shell 在收到一个换行符(new line，ASCII码0x0A)时开始解释命令行的命令</li>
<li>shell 查找命令是否有别名(alias)，如果有则用别名代替命令</li>
<li>如果命令中不包含 &ldquo;/&quot;，shell 首先查找同名函数，如果有，执行这个函数即可</li>
<li>如果没有同名函数则查找内建命令，如果是内建命令，则在bash内部执行即可</li>
<li>如果也不是内建命令，则根据环境变量 <strong>PATH</strong> 的顺序查找命令文件</li>
<li>如果找不到命令文件，则显示错误信息并回到提示符接收下面的命令</li>
<li>如果找到命令文件或者命令中有 &ldquo;/&rdquo; 字符，bash 会 fork 一个子进程，自身进程执行 <strong>wait()</strong> 等待子进程结束，然后在子进程中执行 <strong>execve()</strong>，一切的其他工作交给 <strong>execve()</strong> 来处理</li>
</ul>
</li>
<li><strong>环境变量的传递</strong>
<ul>
<li>
<p>我们看一下 <strong>execve()</strong> 的手册</p>
<p><img src="/images/100001/man-execve.png" alt="execve()说明"></p>
<p><strong>图6：execve()手册</strong></p>
</li>
<li>
<p>在执行 <strong>execve()</strong> 时，需要传递三个参数过去，filename - 要执行的程序文件名；argv[] - 执行这个程序需要的参数；envp - 环境变量；<strong>环境变量就是这样传递给了可执行程序</strong></p>
</li>
<li>
<p>大家可能注意到，shell 不仅可以执行一个二进制的程序，也可以执行一个 shell 脚本(ASCII文本文件)，我们并不需要告诉 shell 我们在执行那种文件，而 shell 却不会搞错，其实这个识别过程也是 <strong>execve()</strong> 的功劳</p>
<blockquote>
<p><strong>execve()</strong> 在执行程序时首先要读出文件的前128个字节，用以分析文件的类别，以便用适当的方式执行这个文件；比如：shell脚本文件的前两个字符是 <strong>&rdquo;#!&quot;</strong>，这一点在手册中有明确说明；ELF文件的前四个字符是：0x45 0x4c 0x46 0x7c等，还有其它不同的可执行格式，这个过程其实还是比较复杂的，但是和 shell 变量毫无关系，所以不在本文讨论的范围内</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>一个打印环境变量的C程序</strong>
<ul>
<li>该程序只是验证传递给子进程的环境变量不包括普通shell变量</li>
<li>源代码，文件名：print_env.c
<pre tabindex="0"><code>#include&lt;stdio.h&gt;

extern char **environ;

int main() {
    int i;

    for (i = 0; environ[i]; i++)
        printf(&#34;*%s\n&#34;, environ[i]);

    return 0;
}
</code></pre></li>
<li>编译执行
<pre tabindex="0"><code>$ gcc print_env.c -o print_env
$ ./print_env
</code></pre></li>
<li>本程序打印出的环境变量与 <em>printenv</em> 命令打印出的结果一致</li>
</ul>
</li>
<li><strong>跟踪程序的执行</strong>
<ul>
<li>
<p>用 <em>strace ./print_env</em> 可以清楚地看到环境变量被传递给了程序 print_env</p>
<p><img src="/images/100001/strace_print_env.png" alt="跟踪程序print_env"></p>
<p><strong>图7：跟踪程序print_env</strong></p>
</li>
<li>
<p>我们先用 <em>printenv|wc -l</em> 打印出环境变量的数量，然后我们看到有相同数量的变量被传递给了我们的程序 print_env</p>
</li>
</ul>
</li>
<li><strong>环境变量对启动程序的影响</strong>
<ul>
<li>
<p>上面这个小程序我们在运行时是使用 <em>./print_env</em> 的方式运行的，其中 &ldquo;./&rdquo; 表示当前路径，但是这个程序其实就在当前目录下，我们为什么一定要指定路径呢？我们试一下不指定路径会怎样</p>
<p><img src="/images/100001/command_not_found.png" alt="command not found"></p>
<ul>
<li><strong>图8：命令执行失败</strong></li>
</ul>
</li>
<li>
<p>这是因为 shell 是沿着环境变量 <strong>PATH</strong> 的顺序来查找命令文件的，而当前目录 ./ 并不在当前的 <strong>PATH</strong> 中，我们可以试着把 ./ 加入到环境变量 <strong>PATH</strong> 中，然后再运行一下试试</p>
<p><img src="/images/100001/print_env_successfully.png" alt="执行print_env成功"></p>
<ul>
<li><strong>图9：执行print_env成功</strong></li>
</ul>
</li>
<li>
<p>正如我们所期待的，执行成功了</p>
</li>
</ul>
</li>
<li><strong>子进程中无法修改父进程环境的环境变量</strong>
<ul>
<li>shell 传递给的程序的环境仅仅是父进程环境的一个副本，所以我们在程序中改变这个副本中的变量都无法改变父进程的环境，当程序运行结束时，这个环境副本将被销毁</li>
<li>下面这个例子我们首先在 shell 下定义一个环境变量 ENV_VAR_1，然后编写一个脚本修改这个环境变量，在脚本退出后我们再次打印这个环境变量
<blockquote>
<p>脚本文件名为：chg_envvar.sh，脚本的代码如下：</p>
</blockquote>
<pre tabindex="0"><code>#!/bin/bash

echo &#34;Print environment variable - ENV_VAR_1&#34;
printenv ENV_VAR_1
echo &#34;Change ENV_VAR_1 to &#39;second_value&#39;&#34;
ENV_VAR_1=&#34;second value&#34;
echo &#34;Again, print environment variable - ENV_VAR_1&#34;
printenv ENV_VAR_1

exit 0
</code></pre><blockquote>
<p>下面我们完成这个测试</p>
</blockquote>
<pre tabindex="0"><code>whowin@ubuntu:~$ chmod +x chg_envvar.sh
whowin@ubuntu:~$ export ENV_VAR_1=&#34;first value&#34;
whowin@ubuntu:~$ printenv ENV_VAR_1
first value
whowin@ubuntu:~$ ./chg_envvar.sh
Print environment variable - ENV_VAR_1
first value
Change ENV_VAR_1 to &#39;second_value&#39;
Again, print environment variable - ENV_VAR_1
second value
whowin@ubuntu:~$ printenv ENV_VAR_1
first value
whowin@ubuntu:~$
</code></pre><blockquote>
<p>我们看到，在脚本内部执行 <em>printenv ENV_VAR_1</em> 时，打印出来的结果已经是 &ldquo;second value&rdquo;，说明我们已经修改成功了这个环境变量的值，但当脚本退出，我们再次打印这个变量时，其值仍然是 &ldquo;first value&rdquo;，并没有改变，这说明我们在子进程中对环境的修改并不能影响到父进程</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="在当前环境下运行程序">在当前环境下运行程序</h2>
<ul>
<li>
<p>我们在前面一再强调，shell 在执行一个程序的时候会先 fork 一个子进程，然后在子进程中执行程序，这实际上是 shell 为执行一个程序新建立了一个环境，然后在这个环境中执行程序，当然这个新环境继承了父进程的环境</p>
</li>
<li>
<p>其实，shell 也可以不 fork 一个子进程，而是直接在当前进程下执行你的程序，shell 下有一个内建命令 <em>source</em> 就是为此而设计的，我们先来看看这个命令的手册</p>
<p><img src="/images/100001/source_help.png" alt="source的help手册"></p>
<p><strong>图10：source命令的help手册</strong></p>
</li>
<li>
<p>说明已经很清楚了，要说明的是 <em>source</em> 命令只能执行脚本文件</p>
</li>
<li>
<p>我们提出的问题是，既然 <em>source</em> 命令是在当前 shell 下执行程序，那是不是意味着上面那个改变环境变量的脚本文件可以改变当前 shell 下的环境变量了呢？我们执行一下试试</p>
</li>
<li>
<p>我们在前面执行脚本时使用的命令是：<em>./chg_envvar.sh</em>，我们已经解释过 &ldquo;./&rdquo; 的含义以及为什么要有 &ldquo;./&quot;，这次我们执行这个脚本准备用 <em>. ./chg_envvar.sh</em> 来执行，只是在原来命令的前面多了 &ldquo;. &ldquo;，点后面有个空格，其实这个 &ldquo;.&rdquo; 就等同于 <em>source</em>，所以这个命令就相当于 <em>source ./chg_envvar.sh</em></p>
<pre tabindex="0"><code>whowin@ubuntu:~$ . ./chg_envvar.sh
</code></pre></li>
<li>
<p>当我们用这种方法执行这个脚本的时候，我们发现意外出现了，整个 shell 都退出了，这是为什么呢？</p>
<blockquote>
<p>这是因为在我们的脚本的最后一行有一个 <strong>exit 0</strong> 语句，正常情况下，如果我们不使用 source 去运行时，<strong>exit</strong> 会退出 shell 为这个脚本建立的子进程，所以一点问题都没有，但是当用 <em>source</em> 去运行这个脚本时，没有建立子进程，那么退出的就是当前 shell 进程，所以你的 shell 就没有了，因为被你运行的脚本退出了；但是如果我们不使用 <strong>exit</strong> 而使用 <strong>return</strong> 退出确实是可以解决在使用 <em>source</em> 命令运行的问题，但是不使用 <em>source</em> 运行就要出问题了，大家自己可以试一下</p>
</blockquote>
<blockquote>
<p>那么是不是可以不写 <strong>exit</strong> 和 <strong>return</strong> 呢？当然可以，但是这不是写 shell 脚本的好习惯，因为执行完你的脚本后，可能还要执行下一个脚本，而下一个脚本可能要判断你的这个脚本的返回值，所以在写脚本时返回一个有意义的值是非常良好的习惯</p>
</blockquote>
<blockquote>
<p>其实我们修改一下这个脚本就可以解决这个问题，这里仅提供源码，解释超出了本文涉及的内容</p>
</blockquote>
<pre tabindex="0"><code>whowin@ubuntu:~$ cat chg_envvar.sh 
#!/bin/bash

echo &#34;Print environment variable - ENV_VAR_1&#34;
printenv ENV_VAR_1
echo &#34;Change ENV_VAR_1 to &#39;second_value&#39;&#34;
ENV_VAR_1=&#34;second value&#34;
echo &#34;Again, print environment variable - ENV_VAR_1&#34;
printenv ENV_VAR_1

if [ $0 != &#34;$BASH_SOURCE&#34; ]; then
    return 0
else
    exit 0
fi
whowin@ubuntu:~$ 
</code></pre></li>
<li>
<p>用这种方法，也可以让某些必须用 <em>source</em> 运行的程序如果没有在 <em>source</em> 下运行，可以给出提示并停止运行</p>
</li>
<li>
<p>现在回到正题，这个脚本能不能改变当前 shell 下的环境变量呢？答案是肯定的。</p>
<pre tabindex="0"><code>whowin@ubuntu:~$ export ENV_VAR_1=&#34;first value&#34;
whowin@ubuntu:~$ printenv ENV_VAR_1
first value
whowin@ubuntu:~$ source ./chg_envvar.sh 
Print environment variable - ENV_VAR_1
first value
Change ENV_VAR_1 to &#39;second_value&#39;
Again, print environment variable - ENV_VAR_1
second value
whowin@ubuntu:~$ printenv ENV_VAR_1
second value
whowin@ubuntu:~$ 
</code></pre></li>
<li>
<p>很显然，脚本 <em>chg_envvar.sh</em> 运行完毕后，我们发现，环境变量 <strong>ENV_VAR_1</strong> 已经发生了改变</p>
</li>
<li>
<p>实际上这种方法是一种常用的方法，常被用于改变当前环境</p>
<blockquote>
<p>在嵌入式开发中，不同的开发板使用的CPU可能不同，这样在交叉编译时的工具链也不同，不同的开发板即便是相同的CPU也可能使用不同的工具链进行编译，比如即便是相同的CPU可能有些需要用软浮点的编译器，有些使用硬浮点的编译器，这时我们可以用上面的方法为每一个交叉编译的工具链写一个脚本，脚本中为某个指定的工具链所需的环境，然后用 <em>source</em> 去运行，下面是我的环境下的一个例子</p>
</blockquote>
<pre tabindex="0"><code>whowin@ubuntu:~$ cat a8.sh
#!/bin/bash
#A8 arm-linux-gnueabi工具链
export PATH=/home/whowin/toolschain/4.5.1/bin:$PATH
whowin@ubuntu:~$ 
</code></pre></li>
</ul>
<h2 id="结语">结语</h2>
<ul>
<li>启动终端程序时启动了 <strong>bash</strong> 进程，使我们可以在 <strong>shell</strong> 下输入命令</li>
<li>环境变量也是 shell 变量，但又与 shell 变量略有不同</li>
<li>环境变量与普通 shell 变量的主要区别是环境变量会传递给新建的子进程</li>
<li>环境变量和普通 shell 变量之间可以使用 <em>export</em> 或 <em>declare</em> 进行转换</li>
<li>shell 可以在当前进程下运行脚本程序(不创建子进程)，这种运行方式常被用于改变当前运行环境下的环境变量</li>
</ul>
		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/shell/" rel="tag">shell</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/bash/" rel="tag">bash</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/source/" rel="tag">source</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/printenv/" rel="tag">printenv</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" rel="tag">环境变量</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/declare/" rel="tag">declare</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/export/" rel="tag">export</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/blog/ansi-escape-code/" rel="prev">
			<span class="pager__subtitle">«&thinsp;上一篇</span>
			<p class="pager__title">ANSI转义序列</p>
		</a>
	</div>
</nav>

<section class="comments">
	<div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "whowin" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2022 whowin.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> 主题</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>